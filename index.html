<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hybrid Sorting Algorithm - MergeSort & Insertion Sort</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="script.js" defer></script>
</head>
<body>
    <div id="page-wrapper">
        <!-- Navigation -->
        <nav id="navbar">
            <ul>
                <li><a href="#description">Description</a></li>
                <li><a href="#team">Team Info</a></li>
                <li><a href="#algorithms">Algorithms</a></li>
                <li><a href="#code">Code</a></li>
                <li><a href="#graph">Dynamic Graph</a></li>
                <li><a href="#conclusion">Conclusion</a></li>
            </ul>
        </nav>

        <!-- Project Description Section -->
        <section id="description">
            <h1>Project 1: Integration of MergeSort & Insertion Sort</h1>
            <p>
                In MergeSort, when the sizes of subarrays are small, the overhead of many recursive calls makes the algorithm inefficient. 
                Therefore, we often combine MergeSort with Insertion Sort to create a hybrid sorting algorithm for better efficiency. 
                The idea is to set a small integer S as a threshold for the size of subarrays. Once the size of a subarray in a recursive 
                call of MergeSort is less than or equal to S, the algorithm switches to Insertion Sort, which is efficient for small-sized input.
            </p>
        </section>

        <!-- Team Information Section -->
        <section id="team">
            <h2>Team Information</h2>
            <div class="team-member">
                <img src="team_member_1.jpg" alt="Team Member 1">
                <h3>Akshay Narayanan</h3>
                <p>Lead Developer & Algorithm Specialist</p>
            </div>
            <div class="team-member">
                <img src="team_member_2.jpg" alt="Team Member 2">
                <h3>Member 2</h3>
                <p>Data Analyst & Researcher</p>
            </div>
            <!-- Add more team members as needed -->
        </section>

        <!-- Algorithms Explanation Section -->
        <section id="algorithms">
            <h2>Algorithms</h2>
            <p>
                <b>MergeSort:</b> MergeSort is a divide-and-conquer algorithm that divides an array into two halves, recursively sorts them, 
                and merges the sorted halves. It has an average time complexity of O(n log n).
            </p>
            <p>
                <b>Insertion Sort:</b> Insertion Sort is efficient for small arrays, where elements are sorted in-place. It has an average time 
                complexity of O(nÂ²).
            </p>
            <p>
                <b>Hybrid Sort (MergeSort + Insertion Sort):</b> This hybrid algorithm switches to Insertion Sort when the subarray size becomes 
                smaller than a predefined threshold S during MergeSort's recursive calls. This improves performance on small datasets.
            </p>
        </section>

        <!-- Code Showcase Section -->
        <section id="code">
            <h2>Code</h2>
            <div class="code-block">
                <h3>MergeSort Code:</h3>
                <pre><code>
function mergeSort(arr) {
    if (arr.length < 2) return arr;
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    return merge(left, right);
}
function merge(left, right) {
    const result = [];
    while (left.length && right.length) {
        if (left[0] < right[0]) result.push(left.shift());
        else result.push(right.shift());
    }
    return [...result, ...left, ...right];
}
                </code></pre>
            </div>
            <div class="code-block">
                <h3>Insertion Sort Code:</h3>
                <pre><code>
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}
                </code></pre>
            </div>
            <div class="code-block">
                <h3>Hybrid Sort Code:</h3>
                <pre><code>
function hybridSort(arr, S) {
    if (arr.length <= S) return insertionSort(arr);
    const mid = Math.floor(arr.length / 2);
    const left = hybridSort(arr.slice(0, mid), S);
    const right = hybridSort(arr.slice(mid), S);
    return merge(left, right);
}
                </code></pre>
            </div>
        </section>

        <!-- Dynamic Graph Section -->
        <section id="graph">
            <h2>Dynamic Graph</h2>
            <label for="array-size">Enter Array Size (1,000 to 10 Million): </label>
            <input type="number" id="array-size" min="1000" max="10000000" value="10000">
            <label for="threshold">Threshold S for Hybrid Sort: </label>
            <input type="number" id="threshold" min="10" max="100" value="50">
            <button onclick="generateGraph()">Generate Graph</button>
            <canvas id="myChart"></canvas>
        </section>

        <!-- Conclusion Section -->
        <section id="conclusion">
            <h2>Conclusion</h2>
            <p>The hybrid algorithm significantly reduces the number of key comparisons and improves performance when the input size is large, especially when the optimal threshold (S) is set correctly.</p>
        </section>
    </div>
</body>
</html>
