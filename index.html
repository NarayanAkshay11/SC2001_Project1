<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sorting Algorithms</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <section id="description" class="section">
            <h1>Project 1: Integration of Mergesort & Insertion Sort</h1>
            <p>In Mergesort, when the sizes of subarrays are small, the overhead of many recursive calls makes the algorithm inefficient. Therefore, in real use, we often combine Mergesort with Insertion Sort to come up with a hybrid sorting algorithm for better efficiency. The idea is to set a small integer S as a threshold for the size of subarrays. Once the size of a subarray in a recursive call of Mergesort is less than or equal to S, the algorithm will switch to Insertion Sort, which is efficient for small-sized input.</p>
            <button id="next-to-team">Next</button>
        </section>

        <section id="team" class="section hidden">
            <h2>Meet the Team</h2>
            <div class="team-member">
                <img src="images/member1.png" alt="Member 1">
                <p>Member 1 - Geeky Pixel Art</p>
            </div>
            <div class="team-member">
                <img src="images/member2.png" alt="Member 2">
                <p>Member 2 - Geeky Pixel Art</p>
            </div>
            <button id="next-to-algorithms">Next</button>
        </section>

        <section id="algorithms" class="section hidden">
            <h2>Algorithms</h2>
            <h3>Mergesort</h3>
            <pre><code>
function mergeSort(arr) {
    if (arr.length <= 1) return arr;
    const mid = Math.floor(arr.length / 2);
    const left = mergeSort(arr.slice(0, mid));
    const right = mergeSort(arr.slice(mid));
    return merge(left, right);
}

function merge(left, right) {
    let result = [], i = 0, j = 0;
    while (i < left.length && j < right.length) {
        if (left[i] < right[j]) result.push(left[i++]);
        else result.push(right[j++]);
    }
    return result.concat(left.slice(i)).concat(right.slice(j));
}
            </code></pre>
            <h3>Insertion Sort</h3>
            <pre><code>
function insertionSort(arr) {
    for (let i = 1; i < arr.length; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}
            </code></pre>
            <h3>Hybrid Algorithm</h3>
            <pre><code>
function hybridSort(arr, threshold) {
    if (arr.length <= threshold) return insertionSort(arr);
    const mid = Math.floor(arr.length / 2);
    return merge(hybridSort(arr.slice(0, mid), threshold), hybridSort(arr.slice(mid), threshold));
}
            </code></pre>
            <button id="next-to-graph">Next</button>
        </section>

        <section id="graph" class="section hidden">
            <h2>Dynamic Graph</h2>
            <label for="array-size">Array Size:</label>
            <input type="number" id="array-size" value="1000">
            <label for="threshold">Threshold (S):</label>
            <input type="number" id="threshold" value="50">
            <button id="generate-graph">Generate Graph</button>
            <canvas id="graph-canvas" width="600" height="400"></canvas>
            <p id="conclusion-text"></p>
            <button id="next-to-conclusion">Next</button>
        </section>

        <section id="conclusion" class="section hidden">
            <h2>Conclusion</h2>
            <p>The graph above shows the number of key comparisons performed by the hybrid sorting algorithm. The comparison with Mergesort and Insertion Sort highlights the efficiency of the hybrid approach, particularly for large datasets.</p>
        </section>
    </div>
    <script src="script.js"></script>
</body>
</html>
